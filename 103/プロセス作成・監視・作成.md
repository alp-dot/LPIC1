# プロセス作成・監視・管理

## 1. プロセスとジョブの基本概念

### プロセス
Linuxにおけるプロセスとは、実行中のプログラムのインスタンスです。各プロセスには一意のプロセスID（PID）が割り当てられ、システムリソース（CPU、メモリなど）を使用します。

### ジョブ
ジョブは、シェルから起動されたプロセスまたはプロセスグループを指します。シェルは各ジョブにジョブ番号を割り当てて管理します。

### プロセスの状態
プロセスには主に以下の状態があります：
- 実行中（Running）
- 停止中（Stopped）
- スリープ（Sleep）
- ゾンビ（Zombie）
- 実行待ち（Waiting）

## 2. プロセス管理の基本コマンド

### 2.1 psコマンド

psコマンドは、システム上で実行中のプロセスの情報を表示します。

#### 基本的な書式
```bash
ps [オプション]
```

#### 主なオプション
- `a`: 端末に紐づく全プロセスを表示
- `u`: ユーザー指向の出力フォーマット
- `x`: 端末に紐づかないプロセスも表示
- `f`: プロセスの親子関係をツリー状で表示
- `-e`: 全プロセスを表示
- `-f`: 詳細情報を表示（full-format）
- `-l`: 詳細情報を表示（long-format）
- `-o format`: 出力フォーマットを指定

#### 使用例
```bash
# 基本的な使用法
ps

# 端末に関連付けられた全プロセスを表示
ps a

# 詳細情報を含む全プロセス一覧
ps aux

# 全プロセスの親子関係をツリー状で表示
ps -ef f
ps axf

# プロセスの親子関係を表示
ps f
```

#### 表示される情報
- `PID`: プロセスID
- `PPID`: 親プロセスID
- `USER`: プロセスの所有者
- `%CPU`: CPU使用率
- `%MEM`: メモリ使用率
- `VSZ`: 仮想メモリサイズ
- `RSS`: 物理メモリサイズ
- `TTY`: 制御端末
- `STAT`: プロセス状態
- `START`: 開始時間
- `TIME`: CPU使用時間
- `COMMAND`: 実行コマンド

### 2.2 topコマンド

topコマンドは、動的にプロセス情報を表示し、リアルタイムでシステムの状態を監視するのに役立ちます。

#### 基本的な書式
```bash
top [オプション]
```

#### 主なオプション
- `-d 秒数`: 更新間隔を指定
- `-p PID`: 指定したPIDのプロセスのみ表示
- `-u ユーザー名`: 指定したユーザーのプロセスのみ表示
- `-b`: バッチモードで実行（出力をリダイレクト可能）

#### 対話モードでのキー操作
- `q`: topを終了
- `h` または `?`: ヘルプの表示
- `k`: プロセスの終了（killコマンド相当）
- `r`: プロセスの優先度変更（reniceコマンド相当）
- `F`: ソートフィールドの変更
- `f`: 表示するフィールドの選択
- `u`: 特定ユーザーのプロセスのみ表示
- `M`: メモリ使用量でソート
- `P`: CPU使用率でソート
- `T`: 実行時間でソート

### 2.3 pstreeコマンド

pstreeコマンドは、プロセスの親子関係をツリー状で表示します。

#### 基本的な書式
```bash
pstree [オプション] [PID/ユーザー名]
```

#### 主なオプション
- `-p`: プロセスIDを表示
- `-a`: コマンドライン引数を表示
- `-u`: ユーザー名を表示
- `-h`: 現在のプロセスを強調表示

#### 使用例
```bash
# 基本的な使用法
pstree

# プロセスIDを含めて表示
pstree -p

# 特定ユーザーのプロセスを表示
pstree username

# 特定のプロセスとその子プロセスを表示
pstree -p 1234
```

## 3. ジョブ管理

### 3.1 バックグラウンドとフォアグラウンド

シェルでは、コマンドをフォアグラウンドまたはバックグラウンドで実行できます。

- **フォアグラウンド**: コマンドが終了するまで、端末は他のコマンドを受け付けません。
- **バックグラウンド**: コマンドを実行しながら、端末で他のコマンドも実行できます。

#### バックグラウンドでの実行
```bash
# コマンドをバックグラウンドで実行
command &

# 例：ファイル検索をバックグラウンドで実行
find / -name "*.log" > log_files.txt &
```

#### バックグラウンドジョブの確認
```bash
# 実行中および停止中のジョブを表示
jobs

# ジョブ番号と状態の詳細を表示
jobs -l
```

### 3.2 ジョブの操作

#### フォアグラウンドへの切り替え
```bash
# カレントジョブ（+マークがついたジョブ）をフォアグラウンドに移動
fg

# 指定したジョブ番号をフォアグラウンドに移動
fg %ジョブ番号
```

#### バックグラウンドへの切り替え
```bash
# 一時停止中のカレントジョブをバックグラウンドで再開
bg

# 指定したジョブをバックグラウンドで再開
bg %ジョブ番号
```

#### ジョブの一時停止
```bash
# フォアグラウンドで実行中のジョブを一時停止する（Ctrl+Z）
```

### 3.3 nohupコマンド

nohupコマンドは、ユーザーがログアウトしても実行を継続できるようにコマンドを実行します。

#### 基本的な書式
```bash
nohup コマンド [引数] [&]
```

#### 使用例
```bash
# ログアウト後も継続するバックグラウンドジョブを作成
nohup long_running_command > output.log 2>&1 &
```

#### 特徴
- HUP（hangup）シグナルを無視する
- 出力は「nohup.out」ファイルにリダイレクトされる（デフォルト）
- バックグラウンド（&）と組み合わせることが一般的

## 4. プロセスの終了とシグナル

### 4.1 killコマンド

killコマンドは、プロセスにシグナルを送信するために使用されます。デフォルトではTERMシグナルが送信されます。

#### 基本的な書式
```bash
kill [オプション] PID
```

#### 主なオプション
- `-l`: シグナル一覧を表示
- `-s シグナル名` または `-シグナル番号`: 送信するシグナルを指定

#### 主なシグナル
- `SIGHUP` (1): ハングアップ（端末の切断など）
- `SIGINT` (2): 割り込み（Ctrl+C）
- `SIGQUIT` (3): 終了とコアダンプ（Ctrl+\\）
- `SIGKILL` (9): 強制終了（プロセスは無視できない）
- `SIGTERM` (15): 終了要求（デフォルト）
- `SIGSTOP` (19): 一時停止（プロセスは無視できない）
- `SIGTSTP` (20): 端末からの一時停止（Ctrl+Z）
- `SIGCONT` (18): 停止していたプロセスを再開

#### 使用例
```bash
# プロセスを終了（デフォルトはTERMシグナル）
kill 1234

# 強制終了（SIGKILLシグナル）
kill -9 1234
kill -KILL 1234

# 一時停止（SIGSTOPシグナル）
kill -STOP 1234

# 実行再開（SIGCONTシグナル）
kill -CONT 1234
```

### 4.2 killallコマンド

killallコマンドは、名前で指定した全てのプロセスにシグナルを送信します。

#### 基本的な書式
```bash
killall [オプション] プロセス名
```

#### 主なオプション
- `-i`: 対話モード（確認を求める）
- `-I`: 大文字小文字を区別しない
- `-u ユーザー`: 特定ユーザーのプロセスのみを対象
- `-s シグナル名` または `-シグナル番号`: 送信するシグナルを指定

#### 使用例
```bash
# 全てのfirefoxプロセスを終了
killall firefox

# 対話モードで全てのfirefoxプロセスを終了
killall -i firefox

# 特定ユーザーのfirefoxプロセスのみを強制終了
killall -u username -9 firefox
```

### 4.3 pkillコマンド

pkillコマンドは、名前やその他の属性でプロセスにシグナルを送信します。

#### 基本的な書式
```bash
pkill [オプション] パターン
```

#### 主なオプション
- `-f`: コマンドライン全体でパターンを検索
- `-u ユーザー`: 特定ユーザーのプロセスのみを対象
- `-t 端末`: 特定の端末に関連付けられたプロセスを対象
- `-P PPID`: 特定の親プロセスの子プロセスを対象
- `-シグナル名` または `-シグナル番号`: 送信するシグナルを指定

#### 使用例
```bash
# 名前でプロセスを終了
pkill firefox

# 名前の一部でプロセスを終了
pkill fire

# コマンドライン全体でパターン検索
pkill -f "firefox -private"

# 特定ユーザーのfirefoxプロセスを終了
pkill -u username firefox
```

## 5. 実践例

### 例1：バックグラウンドジョブの作成と管理
```bash
# バックグラウンドでファイル検索を実行
find / -name "*.log" > logs.txt &
[1] 1234

# 実行中のジョブを確認
jobs
[1]+  Running    find / -name "*.log" > logs.txt &

# 別のジョブを開始し、すぐに停止
sleep 100
[Ctrl+Z]
[2]+  Stopped    sleep 100

# 停止したジョブをバックグラウンドで再開
bg %2
[2]+ sleep 100 &

# 最初のジョブをフォアグラウンドに移動
fg %1
```

### 例2：プロセスの監視と終了
```bash
# 特定ユーザーのプロセスを監視
ps -u username

# システム負荷の高いプロセスを特定
top -c

# 特定のプロセスの親子関係を確認
pstree -p 1234

# プロセスを終了
kill -15 1234

# プロセスが終了しない場合、強制終了
kill -9 1234
```

### 例3：nohupを使用した長時間実行コマンド
```bash
# ログアウト後も継続するコマンドを実行
nohup find / -type f -name "*.log" -exec cp {} /backup/logs/ \; > find_output.log 2>&1 &

# 実行状況の確認
ps -fp $(pgrep -f "find / -type")
```

## 6. LPIC試験のポイント

- psコマンドの主要なオプションとその出力形式
- プロセスの状態とその意味
- ジョブ制御の基本コマンド（jobs, fg, bg）の使用法
- killコマンドの使用法と主なシグナル
- nohupコマンドの目的と使用法
- バックグラウンド実行の方法と管理
- プロセスの親子関係の理解と表示方法

## 練習問題

### 問題1：nohupコマンドの説明

コマンド「nohup コマンド &」の正しい説明は次のうちどれか。

#### 選択肢
- コマンド実行でエラーが起きた場合にプロセスへSIGTSTPを送り続ける
- ユーザがログアウトしても、指定のコマンドをバックグラウンドで実行し続ける
- フォアグラウンドで実行してSIGHUPを無視する
- ログアウト処理の直前にコマンドにSIGINTを送り正常に終了する
- バックグラウンドでコマンドをハングアップする

#### 解説

正解は「ユーザがログアウトしても、指定のコマンドをバックグラウンドで実行し続ける」です。

nohupコマンドはHUP（hangup）シグナルを無視するようにコマンドを実行します。Linuxでは、ユーザーがログアウトすると、そのユーザーのすべてのプロセスにHUP（SIGHUP）シグナルが送信されます。通常、このシグナルを受け取ったプロセスは終了しますが、nohupを使用すると、このシグナルを無視して実行を継続できます。

コマンドライン末尾の「&」は、コマンドをバックグラウンドで実行することを意味します。これにより、ユーザーはコマンドの実行中でも別の操作を行うことができます。

### 問題2：シグナルの種類

killコマンドでシグナル名やシグナル番号を指定しない場合、デフォルトで送信されるシグナルは次のうちどれか。

#### 選択肢
- INT (SIGINT)
- KILL (SIGKILL)
- TERM (SIGTERM)
- HUP (SIGHUP)
- STOP (SIGSTOP)

#### 解説

正解は「TERM (SIGTERM)」です。

killコマンドでシグナル名またはシグナル番号を指定しない場合、デフォルトでTERM（SIGTERM）シグナルが送信されます。これは、プロセスに対して「終了してください」と要求するシグナルです。このシグナルを受け取ったプロセスは、通常は適切に終了処理を行ってから終了します。

ただし、TERMシグナルはプロセスによって無視される可能性があります。プロセスを強制的に終了させる必要がある場合は、KILL（SIGKILL）シグナルを使用します（例：kill -9 PID）。

### 問題3：ジョブのフォアグラウンド実行

以下のようなジョブ表示がある場合、ジョブ番号2のジョブ（vim test.txt）をフォアグラウンド動作に切り替える適切なコマンドはどれか。

```
[1]   Running                 find / -name "*.log" > logs.txt &
[2]+  Stopped                 vim test.txt
```

#### 選択肢
- bg 2
- bg
- fg
- jobs 2
- fg 2

#### 解説

正解は「fg」と「fg 2」です。

バックグラウンドで動作中または一時停止中のジョブをフォアグラウンド動作に切り替えるには、fgコマンドを使用します。ジョブ番号を指定する場合は「fg 2」のようにします。

ジョブ番号を指定しない場合（「fg」のみ）、カレントジョブが対象になります。カレントジョブは、通常、jobsコマンドの出力で「+」マークが付いているジョブです。この例では、ジョブ番号2（vim test.txt）が「+」マークを持つカレントジョブであるため、「fg」と「fg 2」は同じ結果になります。

「bg」と「bg 2」は一時停止中のジョブをバックグラウンドで再開するコマンドで、「jobs 2」はジョブの状態を表示するだけなので、いずれも不適切です。

---

## 参考資料
- Linux標準教科書（LPI）
- Linux Process Management（O'Reilly）
- Man pages for ps, top, kill, fg, bg, jobs, nohup
- Advanced Linux Programming